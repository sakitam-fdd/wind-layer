const M=Object.prototype.hasOwnProperty,x=typeof Symbol<"u"?Symbol.toStringTag:void 0;function P(n){if(n===null)return n===void 0?"[object Undefined]":"[object Null]";if(!(x&&x in Object(n)))return toString.call(n);const t=M.call(n,x),i=n[x];let s=!1;try{n[x]=void 0,s=!0}catch{}const e=Object.prototype.toString.call(n);return s&&(t?n[x]=i:delete n[x]),e}function m(n){if(!I(n))return!1;const t=P(n);return t==="[object Function]"||t==="[object AsyncFunction]"||t==="[object GeneratorFunction]"||t==="[object Proxy]"}function I(n){const t=typeof n;return n!==null&&(t==="object"||t==="function")}function X(n){return n==null?!1:typeof n=="string"||n.constructor!==null&&n.constructor===String}function g(n){return Object.prototype.toString.call(n)==="[object Number]"&&!isNaN(n)}function O(n){return Array.isArray(n)}function D(n,...t){return Object.assign(n,...t)}function F(n,t){console.warn(`${t||"wind-layer"}: ${n}`)}const w={};function C(n,t){w[t]||(F(t,n),w[t]=!0)}function V(n,t){return n-t*Math.floor(n/t)}function f(n){return n!=null&&!isNaN(n)}function N(n,t={}){let i,s;if(n.forEach(function(r){switch(r.header.parameterCategory+","+r.header.parameterNumber){case"1,2":case"2,2":i=r;break;case"1,3":case"2,3":s=r;break}}),!s||!i)return;const e=i.header;return new S({xmin:e.lo1,ymin:e.la1,xmax:e.lo2,ymax:e.la2,deltaX:e.dx,deltaY:e.dy,cols:e.nx,rows:e.ny,us:i.data,vs:s.data,...t})}function R(n,t,i,s){if(typeof document<"u"){const e=document.createElement("canvas");return e.width=n*i,e.height=t*i,e}else return new s(n*i,t*i)}function T(n){return n?(n.parentNode&&n.parentNode.removeChild(n),n):null}function k(n,t){n=n.split("."),t=t.split(".");const i=Math.max(n.length,t.length);for(;n.length<i;)n.push("0");for(;t.length<i;)t.push("0");for(let s=0;s<i;s++){const e=parseInt(n[s]),o=parseInt(t[s]);if(e>o)return 1;if(e<o)return-1}return 0}class A{constructor(t,i){this.u=t,this.v=i,this.m=this.magnitude()}magnitude(){return Math.sqrt(this.u**2+this.v**2)}directionTo(){let i=Math.atan2(this.u,this.v)*(180/Math.PI);return i<0&&(i+=360),i}directionFrom(){return(this.directionTo()+180)%360}}class S{constructor(t){this.grid=[],this.xmin=t.xmin,this.xmax=t.xmax,this.ymin=t.ymin,this.ymax=t.ymax,this.cols=t.cols,this.rows=t.rows,this.us=t.us,this.vs=t.vs,this.deltaX=t.deltaX,this.deltaY=t.deltaY,this.flipY=!!t.flipY,this.ymin=Math.min(t.ymax,t.ymin),this.ymax=Math.max(t.ymax,t.ymin),this.deltaY<0&&this.ymin<this.ymax||(t.flipY===void 0&&(this.flipY=!0),console.warn("[wind-core]: The data is flipY")),this.isFields=!0;const i=Math.ceil((this.xmax-this.xmin)/t.deltaX),s=Math.ceil((this.ymax-this.ymin)/t.deltaY);(i!==this.cols||s!==this.rows)&&console.warn("[wind-core]: The data grid not equal"),this.isContinuous=Math.floor(this.cols*t.deltaX)>=360,this.translateX="translateX"in t?t.translateX:this.xmax>180,"wrappedX"in t&&C("[wind-core]: ","`wrappedX` namespace will deprecated please use `translateX` insteadÔºÅ"),this.wrapX=!!t.wrapX,this.grid=this.buildGrid(),this.range=this.calculateRange()}buildGrid(){const t=[];let i=0;const{rows:s,cols:e,us:o,vs:r}=this;for(let h=0;h<s;h++){const a=[];for(let l=0;l<e;l++,i++){const u=o[i],c=r[i],d=this.isValid(u)&&this.isValid(c);a[l]=d?new A(u,c):null}this.isContinuous&&a.push(a[0]),t[h]=a}return t}release(){this.grid=[]}extent(){return[this.xmin,this.ymin,this.xmax,this.ymax]}bilinearInterpolateVector(t,i,s,e,o,r){const h=1-t,a=1-i,l=h*a,u=t*a,c=h*i,d=t*i,p=s.u*l+e.u*u+o.u*c+r.u*d,j=s.v*l+e.v*u+o.v*c+r.v*d;return new A(p,j)}calculateRange(){if(!this.grid||!this.grid[0])return;const t=this.grid.length,i=this.grid[0].length;let s,e;for(let o=0;o<t;o++)for(let r=0;r<i;r++){const h=this.grid[o][r];if(h!==null){const a=h.m||h.magnitude();s===void 0?s=a:e===void 0?(e=a,s=Math.min(s,e),e=Math.max(s,e)):(s=Math.min(a,s),e=Math.max(a,e))}}return[s,e]}isValid(t){return t!=null}getWrappedLongitudes(){let t=this.xmin,i=this.xmax;return this.translateX&&(this.isContinuous?(t=-180,i=180):(i=this.xmax-360,t=this.xmin-360)),[t,i]}contains(t,i){const[s,e]=this.getWrappedLongitudes();e>180&&t>=-180&&t<=e-360?t+=360:s<-180&&t<=180&&t>=s+360&&(t-=360);const o=t>=s&&t<=e;let r;return this.deltaY>=0?r=i>=this.ymin&&i<=this.ymax:r=i>=this.ymax&&i<=this.ymin,o&&r}getDecimalIndexes(t,i){const s=V(t-this.xmin,360)/this.deltaX;if(this.flipY){const e=(this.ymax-i)/this.deltaY;return[s,e]}else{const e=(this.ymin+i)/this.deltaY;return[s,e]}}valueAt(t,i){let s=!1;if((this.wrapX||this.contains(t,i))&&(s=!0),!s)return null;const e=this.getDecimalIndexes(t,i),o=Math.floor(e[0]),r=Math.floor(e[1]),h=this.clampColumnIndex(o),a=this.clampRowIndex(r);return this.valueAtIndexes(h,a)}interpolatedValueAt(t,i){let s=!1;if((this.wrapX||this.contains(t,i))&&(s=!0),!s)return null;const[e,o]=this.getDecimalIndexes(t,i);return this.interpolatePoint(e,o)}hasValueAt(t,i){return this.valueAt(t,i)!==null}interpolatePoint(t,i){const s=this.getFourSurroundingIndexes(t,i),[e,o,r,h]=s,a=this.getFourSurroundingValues(e,o,r,h);if(a){const[l,u,c,d]=a;return this.bilinearInterpolateVector(t-e,i-r,l,u,c,d)}return null}clampColumnIndex(t){let i=t;t<0&&(i=0);const s=this.cols-1;return t>s&&(i=s),i}clampRowIndex(t){let i=t;t<0&&(i=0);const s=this.rows-1;return t>s&&(i=s),i}getFourSurroundingIndexes(t,i){const s=Math.floor(t);let e=s+1;this.isContinuous&&e>=this.cols&&(e=0),e=this.clampColumnIndex(e);const o=this.clampRowIndex(Math.floor(i)),r=this.clampRowIndex(o+1);return[s,e,o,r]}getFourSurroundingValues(t,i,s,e){let o;if(o=this.grid[s]){const r=o[t],h=o[i];if(this.isValid(r)&&this.isValid(h)&&(o=this.grid[e])){const a=o[t],l=o[i];if(this.isValid(a)&&this.isValid(l))return[r,h,a,l]}}return null}valueAtIndexes(t,i){return this.grid[i][t]}lonLatAtIndexes(t,i){const s=this.longitudeAtX(t),e=this.latitudeAtY(i);return[s,e]}longitudeAtX(t){const i=this.deltaX/2;let s=this.xmin+i+t*this.deltaX;return this.translateX&&(s=s>180?s-360:s),s}latitudeAtY(t){const i=this.deltaY/2;return this.ymax-i-t*this.deltaY}randomize(t={},i,s,e){const o=Math.random()*(i||this.cols)|0,r=Math.random()*(s||this.rows)|0,h=e([o,r]);return h!==null?(t.x=h[0],t.y=h[1]):(t.x=this.longitudeAtX(o),t.y=this.latitudeAtY(r)),t}checkFields(){return this.isFields}}const Y={globalAlpha:.9,lineWidth:1,colorScale:"#fff",velocityScale:1/25,maxAge:90,paths:800,frameRate:20,useCoordsDraw:!0,gpet:!0};function b(n,t,i,s){return Math.max(0,Math.min(s.length-1,Math.round((n-t)/(i-t)*(s.length-1))))}const y=class y{constructor(t,i,s){if(this.particles=[],this.generated=!1,this.ctx=t,!this.ctx)throw new Error("ctx error");this.animate=this.animate.bind(this),this.setOptions(i),s&&this.updateData(s)}setOptions(t){this.options={...Y,...t};const{width:i,height:s}=this.ctx.canvas;"particleAge"in t&&!("maxAge"in t)&&g(this.options.particleAge)&&(this.options.maxAge=this.options.particleAge),"particleMultiplier"in t&&!("paths"in t)&&g(this.options.particleMultiplier)&&(this.options.paths=Math.round(i*s*this.options.particleMultiplier)),this.prerender()}getOptions(){return this.options}updateData(t){this.field=t,this.generated&&(this.particles=this.prepareParticlePaths())}project(...t){throw new Error("project must be overriden")}unproject(...t){throw new Error("unproject must be overriden")}intersectsCoordinate(t){throw new Error("must be overriden")}clearCanvas(){this.stop(),this.ctx.clearRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height),this.forceStop=!1}isStop(){return!this.starting}start(){this.starting=!0,this.forceStop=!1,this.then=Date.now(),this.animate()}stop(){cancelAnimationFrame(this.animationLoop),this.starting=!1,this.forceStop=!0}animate(){this.animationLoop&&cancelAnimationFrame(this.animationLoop),this.animationLoop=requestAnimationFrame(this.animate);const t=Date.now(),i=t-this.then;i>this.options.frameRate&&(this.then=t-i%this.options.frameRate,this.render())}prerender(){this.generated=!1,this.field&&(this.particles=this.prepareParticlePaths(),this.generated=!0,!this.starting&&!this.forceStop&&(this.starting=!0,this.then=Date.now(),this.animate()))}render(){this.moveParticles(),this.drawParticles(),this.postrender()}postrender(){}moveParticles(){const{width:t,height:i}=this.ctx.canvas,s=this.particles,e=this.options.maxAge,o=m(this.options.velocityScale)?this.options.velocityScale():this.options.velocityScale;let r=0;const h=s.length;for(;r<h;r++){const a=s[r];a.age>e&&(a.age=0,this.field.randomize(a,t,i,this.unproject));const l=a.x,u=a.y,c=this.field.interpolatedValueAt(l,u);if(c===null)a.age=e;else{const d=l+c.u*o,p=u+c.v*o;this.field.hasValueAt(d,p)?(a.xt=d,a.yt=p,a.m=c.m):(a.x=d,a.y=p,a.age=e)}a.age++}}fadeIn(){const t=this.ctx.globalCompositeOperation;this.ctx.globalCompositeOperation="destination-in",this.ctx.fillRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height),this.ctx.globalCompositeOperation=t}drawParticles(){const t=this.particles;this.fadeIn(),this.ctx.globalAlpha=this.options.globalAlpha,this.ctx.fillStyle=`rgba(0, 0, 0, ${this.options.globalAlpha})`,this.ctx.lineWidth=g(this.options.lineWidth)?this.options.lineWidth:1,this.ctx.strokeStyle=X(this.options.colorScale)?this.options.colorScale:"#fff";let i=0;const s=t.length;if(this.field&&s>0){let e,o;for(f(this.options.minVelocity)&&f(this.options.maxVelocity)?(e=this.options.minVelocity,o=this.options.maxVelocity):[e,o]=this.field.range;i<s;i++)this[this.options.useCoordsDraw?"drawCoordsParticle":"drawPixelParticle"](t[i],e,o)}}drawPixelParticle(t,i,s){const e=[t.x,t.y],o=[t.xt,t.yt];if(o&&e&&f(o[0])&&f(o[1])&&f(e[0])&&f(e[1])&&t.age<=this.options.maxAge){if(this.ctx.beginPath(),this.ctx.moveTo(e[0],e[1]),this.ctx.lineTo(o[0],o[1]),m(this.options.colorScale))this.ctx.strokeStyle=this.options.colorScale(t.m);else if(Array.isArray(this.options.colorScale)){const r=b(t.m,i,s,this.options.colorScale);this.ctx.strokeStyle=this.options.colorScale[r]}m(this.options.lineWidth)&&(this.ctx.lineWidth=this.options.lineWidth(t.m)),t.x=t.xt,t.y=t.yt,this.ctx.stroke()}}drawCoordsParticle(t,i,s){const e=[t.x,t.y],o=[t.xt,t.yt];if(o&&e&&f(o[0])&&f(o[1])&&f(e[0])&&f(e[1])&&this.intersectsCoordinate(o)&&t.age<=this.options.maxAge){const r=this.project(e),h=this.project(o);if(r&&h){if(this.ctx.beginPath(),this.ctx.moveTo(r[0],r[1]),this.ctx.lineTo(h[0],h[1]),t.x=t.xt,t.y=t.yt,m(this.options.colorScale))this.ctx.strokeStyle=this.options.colorScale(t.m);else if(Array.isArray(this.options.colorScale)){const a=b(t.m,i,s,this.options.colorScale);this.ctx.strokeStyle=this.options.colorScale[a]}m(this.options.lineWidth)&&(this.ctx.lineWidth=this.options.lineWidth(t.m)),this.ctx.stroke()}}}prepareParticlePaths(){const{width:t,height:i}=this.ctx.canvas,s=typeof this.options.paths=="function"?this.options.paths(this):this.options.paths,e=[];if(!this.field)return[];let o=0;for(;o<s;o++)e.push(this.field.randomize({age:this.randomize()},t,i,this.unproject));return e}randomize(){return Math.floor(Math.random()*this.options.maxAge)}};y.Field=S;let v=y;export{S as F,v as W,D as a,k as b,R as c,Y as d,N as f,O as i,T as r,F as w};
